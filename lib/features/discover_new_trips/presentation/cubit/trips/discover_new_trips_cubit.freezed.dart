// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'discover_new_trips_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$DiscoverNewTripsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)
        normal,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)?
        normal,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)?
        normal,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StateInitial value) initial,
    required TResult Function(_StateNormal value) normal,
    required TResult Function(_StateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StateInitial value)? initial,
    TResult? Function(_StateNormal value)? normal,
    TResult? Function(_StateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StateInitial value)? initial,
    TResult Function(_StateNormal value)? normal,
    TResult Function(_StateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DiscoverNewTripsStateCopyWith<$Res> {
  factory $DiscoverNewTripsStateCopyWith(DiscoverNewTripsState value,
          $Res Function(DiscoverNewTripsState) then) =
      _$DiscoverNewTripsStateCopyWithImpl<$Res, DiscoverNewTripsState>;
}

/// @nodoc
class _$DiscoverNewTripsStateCopyWithImpl<$Res,
        $Val extends DiscoverNewTripsState>
    implements $DiscoverNewTripsStateCopyWith<$Res> {
  _$DiscoverNewTripsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StateInitialImplCopyWith<$Res> {
  factory _$$StateInitialImplCopyWith(
          _$StateInitialImpl value, $Res Function(_$StateInitialImpl) then) =
      __$$StateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StateInitialImplCopyWithImpl<$Res>
    extends _$DiscoverNewTripsStateCopyWithImpl<$Res, _$StateInitialImpl>
    implements _$$StateInitialImplCopyWith<$Res> {
  __$$StateInitialImplCopyWithImpl(
      _$StateInitialImpl _value, $Res Function(_$StateInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StateInitialImpl with DiagnosticableTreeMixin implements _StateInitial {
  const _$StateInitialImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DiscoverNewTripsState.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'DiscoverNewTripsState.initial'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)
        normal,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)?
        normal,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)?
        normal,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StateInitial value) initial,
    required TResult Function(_StateNormal value) normal,
    required TResult Function(_StateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StateInitial value)? initial,
    TResult? Function(_StateNormal value)? normal,
    TResult? Function(_StateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StateInitial value)? initial,
    TResult Function(_StateNormal value)? normal,
    TResult Function(_StateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _StateInitial implements DiscoverNewTripsState {
  const factory _StateInitial() = _$StateInitialImpl;
}

/// @nodoc
abstract class _$$StateNormalImplCopyWith<$Res> {
  factory _$$StateNormalImplCopyWith(
          _$StateNormalImpl value, $Res Function(_$StateNormalImpl) then) =
      __$$StateNormalImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String query,
      List<Trip> trips,
      List<Trip> filteredTrips,
      bool searchDescription,
      bool isMoreSectionOpen,
      Set<Language> selectedLanguages,
      String languageQuery,
      Set<Language> availableLanguages,
      bool showOnlySelectedLanguages});
}

/// @nodoc
class __$$StateNormalImplCopyWithImpl<$Res>
    extends _$DiscoverNewTripsStateCopyWithImpl<$Res, _$StateNormalImpl>
    implements _$$StateNormalImplCopyWith<$Res> {
  __$$StateNormalImplCopyWithImpl(
      _$StateNormalImpl _value, $Res Function(_$StateNormalImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? query = null,
    Object? trips = null,
    Object? filteredTrips = null,
    Object? searchDescription = null,
    Object? isMoreSectionOpen = null,
    Object? selectedLanguages = null,
    Object? languageQuery = null,
    Object? availableLanguages = null,
    Object? showOnlySelectedLanguages = null,
  }) {
    return _then(_$StateNormalImpl(
      query: null == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String,
      trips: null == trips
          ? _value._trips
          : trips // ignore: cast_nullable_to_non_nullable
              as List<Trip>,
      filteredTrips: null == filteredTrips
          ? _value._filteredTrips
          : filteredTrips // ignore: cast_nullable_to_non_nullable
              as List<Trip>,
      searchDescription: null == searchDescription
          ? _value.searchDescription
          : searchDescription // ignore: cast_nullable_to_non_nullable
              as bool,
      isMoreSectionOpen: null == isMoreSectionOpen
          ? _value.isMoreSectionOpen
          : isMoreSectionOpen // ignore: cast_nullable_to_non_nullable
              as bool,
      selectedLanguages: null == selectedLanguages
          ? _value._selectedLanguages
          : selectedLanguages // ignore: cast_nullable_to_non_nullable
              as Set<Language>,
      languageQuery: null == languageQuery
          ? _value.languageQuery
          : languageQuery // ignore: cast_nullable_to_non_nullable
              as String,
      availableLanguages: null == availableLanguages
          ? _value._availableLanguages
          : availableLanguages // ignore: cast_nullable_to_non_nullable
              as Set<Language>,
      showOnlySelectedLanguages: null == showOnlySelectedLanguages
          ? _value.showOnlySelectedLanguages
          : showOnlySelectedLanguages // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$StateNormalImpl with DiagnosticableTreeMixin implements _StateNormal {
  const _$StateNormalImpl(
      {this.query = '',
      required final List<Trip> trips,
      required final List<Trip> filteredTrips,
      this.searchDescription = false,
      this.isMoreSectionOpen = false,
      required final Set<Language> selectedLanguages,
      this.languageQuery = '',
      required final Set<Language> availableLanguages,
      this.showOnlySelectedLanguages = false})
      : _trips = trips,
        _filteredTrips = filteredTrips,
        _selectedLanguages = selectedLanguages,
        _availableLanguages = availableLanguages;

  @override
  @JsonKey()
  final String query;
  final List<Trip> _trips;
  @override
  List<Trip> get trips {
    if (_trips is EqualUnmodifiableListView) return _trips;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_trips);
  }

  final List<Trip> _filteredTrips;
  @override
  List<Trip> get filteredTrips {
    if (_filteredTrips is EqualUnmodifiableListView) return _filteredTrips;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filteredTrips);
  }

  @override
  @JsonKey()
  final bool searchDescription;
  @override
  @JsonKey()
  final bool isMoreSectionOpen;
  final Set<Language> _selectedLanguages;
  @override
  Set<Language> get selectedLanguages {
    if (_selectedLanguages is EqualUnmodifiableSetView)
      return _selectedLanguages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_selectedLanguages);
  }

  @override
  @JsonKey()
  final String languageQuery;
  final Set<Language> _availableLanguages;
  @override
  Set<Language> get availableLanguages {
    if (_availableLanguages is EqualUnmodifiableSetView)
      return _availableLanguages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_availableLanguages);
  }

  @override
  @JsonKey()
  final bool showOnlySelectedLanguages;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DiscoverNewTripsState.normal(query: $query, trips: $trips, filteredTrips: $filteredTrips, searchDescription: $searchDescription, isMoreSectionOpen: $isMoreSectionOpen, selectedLanguages: $selectedLanguages, languageQuery: $languageQuery, availableLanguages: $availableLanguages, showOnlySelectedLanguages: $showOnlySelectedLanguages)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DiscoverNewTripsState.normal'))
      ..add(DiagnosticsProperty('query', query))
      ..add(DiagnosticsProperty('trips', trips))
      ..add(DiagnosticsProperty('filteredTrips', filteredTrips))
      ..add(DiagnosticsProperty('searchDescription', searchDescription))
      ..add(DiagnosticsProperty('isMoreSectionOpen', isMoreSectionOpen))
      ..add(DiagnosticsProperty('selectedLanguages', selectedLanguages))
      ..add(DiagnosticsProperty('languageQuery', languageQuery))
      ..add(DiagnosticsProperty('availableLanguages', availableLanguages))
      ..add(DiagnosticsProperty(
          'showOnlySelectedLanguages', showOnlySelectedLanguages));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StateNormalImpl &&
            (identical(other.query, query) || other.query == query) &&
            const DeepCollectionEquality().equals(other._trips, _trips) &&
            const DeepCollectionEquality()
                .equals(other._filteredTrips, _filteredTrips) &&
            (identical(other.searchDescription, searchDescription) ||
                other.searchDescription == searchDescription) &&
            (identical(other.isMoreSectionOpen, isMoreSectionOpen) ||
                other.isMoreSectionOpen == isMoreSectionOpen) &&
            const DeepCollectionEquality()
                .equals(other._selectedLanguages, _selectedLanguages) &&
            (identical(other.languageQuery, languageQuery) ||
                other.languageQuery == languageQuery) &&
            const DeepCollectionEquality()
                .equals(other._availableLanguages, _availableLanguages) &&
            (identical(other.showOnlySelectedLanguages,
                    showOnlySelectedLanguages) ||
                other.showOnlySelectedLanguages == showOnlySelectedLanguages));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      query,
      const DeepCollectionEquality().hash(_trips),
      const DeepCollectionEquality().hash(_filteredTrips),
      searchDescription,
      isMoreSectionOpen,
      const DeepCollectionEquality().hash(_selectedLanguages),
      languageQuery,
      const DeepCollectionEquality().hash(_availableLanguages),
      showOnlySelectedLanguages);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StateNormalImplCopyWith<_$StateNormalImpl> get copyWith =>
      __$$StateNormalImplCopyWithImpl<_$StateNormalImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)
        normal,
    required TResult Function(String message) error,
  }) {
    return normal(
        query,
        trips,
        filteredTrips,
        searchDescription,
        isMoreSectionOpen,
        selectedLanguages,
        languageQuery,
        availableLanguages,
        showOnlySelectedLanguages);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)?
        normal,
    TResult? Function(String message)? error,
  }) {
    return normal?.call(
        query,
        trips,
        filteredTrips,
        searchDescription,
        isMoreSectionOpen,
        selectedLanguages,
        languageQuery,
        availableLanguages,
        showOnlySelectedLanguages);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)?
        normal,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (normal != null) {
      return normal(
          query,
          trips,
          filteredTrips,
          searchDescription,
          isMoreSectionOpen,
          selectedLanguages,
          languageQuery,
          availableLanguages,
          showOnlySelectedLanguages);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StateInitial value) initial,
    required TResult Function(_StateNormal value) normal,
    required TResult Function(_StateError value) error,
  }) {
    return normal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StateInitial value)? initial,
    TResult? Function(_StateNormal value)? normal,
    TResult? Function(_StateError value)? error,
  }) {
    return normal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StateInitial value)? initial,
    TResult Function(_StateNormal value)? normal,
    TResult Function(_StateError value)? error,
    required TResult orElse(),
  }) {
    if (normal != null) {
      return normal(this);
    }
    return orElse();
  }
}

abstract class _StateNormal implements DiscoverNewTripsState {
  const factory _StateNormal(
      {final String query,
      required final List<Trip> trips,
      required final List<Trip> filteredTrips,
      final bool searchDescription,
      final bool isMoreSectionOpen,
      required final Set<Language> selectedLanguages,
      final String languageQuery,
      required final Set<Language> availableLanguages,
      final bool showOnlySelectedLanguages}) = _$StateNormalImpl;

  String get query;
  List<Trip> get trips;
  List<Trip> get filteredTrips;
  bool get searchDescription;
  bool get isMoreSectionOpen;
  Set<Language> get selectedLanguages;
  String get languageQuery;
  Set<Language> get availableLanguages;
  bool get showOnlySelectedLanguages;
  @JsonKey(ignore: true)
  _$$StateNormalImplCopyWith<_$StateNormalImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StateErrorImplCopyWith<$Res> {
  factory _$$StateErrorImplCopyWith(
          _$StateErrorImpl value, $Res Function(_$StateErrorImpl) then) =
      __$$StateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$StateErrorImplCopyWithImpl<$Res>
    extends _$DiscoverNewTripsStateCopyWithImpl<$Res, _$StateErrorImpl>
    implements _$$StateErrorImplCopyWith<$Res> {
  __$$StateErrorImplCopyWithImpl(
      _$StateErrorImpl _value, $Res Function(_$StateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$StateErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$StateErrorImpl with DiagnosticableTreeMixin implements _StateError {
  const _$StateErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DiscoverNewTripsState.error(message: $message)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DiscoverNewTripsState.error'))
      ..add(DiagnosticsProperty('message', message));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StateErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StateErrorImplCopyWith<_$StateErrorImpl> get copyWith =>
      __$$StateErrorImplCopyWithImpl<_$StateErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)
        normal,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)?
        normal,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            String query,
            List<Trip> trips,
            List<Trip> filteredTrips,
            bool searchDescription,
            bool isMoreSectionOpen,
            Set<Language> selectedLanguages,
            String languageQuery,
            Set<Language> availableLanguages,
            bool showOnlySelectedLanguages)?
        normal,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StateInitial value) initial,
    required TResult Function(_StateNormal value) normal,
    required TResult Function(_StateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StateInitial value)? initial,
    TResult? Function(_StateNormal value)? normal,
    TResult? Function(_StateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StateInitial value)? initial,
    TResult Function(_StateNormal value)? normal,
    TResult Function(_StateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _StateError implements DiscoverNewTripsState {
  const factory _StateError({required final String message}) = _$StateErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$StateErrorImplCopyWith<_$StateErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
